# 문자 단위 이동 명세

이 문서는 텍스트 에디터에서 문자 단위 커서 이동의 동작 명세를 정의합니다.

## 개요

문자 단위 이동은 사용자가 화살표 키나 프로그래밍 API 호출을 통해 텍스트 콘텐츠를 한 문자씩 탐색할 수 있게 합니다. 에디터는 일반 텍스트 노드와 원자 컴포넌트(`<hr>`, `<img>` 같은 단일 단위로 취급되는 요소) 모두를 처리합니다.

## 핵심 개념

### Position
`Position`은 커서 위치를 나타내며 다음을 포함합니다:
- `node: Node` - 커서를 포함하는 DOM 노드
- `offset: number` - 해당 노드 내에서의 문자 오프셋

**중요**: DOM Range API와 달리 element offset은 글자와 동일하게 취급됩니다. 즉, element 노드에서 offset 1은 첫 번째 자식 요소의 "한 글자" 위치를 의미하며, 이는 문자 단위 이동에서 하나의 스텝으로 간주됩니다.

### 원자 컴포넌트
`atomic-component` 클래스가 있는 요소는 단일 단위로 취급됩니다:
- 커서는 시작(offset 0) 또는 끝(offset 1)에만 위치할 수 있음
- 중간에 커서를 배치할 수 없음
- 예시: `<hr>`, `<img>`, `<table>`

## 이동 규칙

### 텍스트 노드 탐색

#### 전진 이동
1. **텍스트 내부**: 오프셋 N에서 N+1로 이동
2. **텍스트 끝**: 다음 사용 가능한 위치로 이동(텍스트 노드 또는 원자 컴포넌트 시작)
3. **문서 끝**: 현재 위치에 유지

#### 후진 이동  
1. **텍스트 내부**: 오프셋 N에서 N-1로 이동
2. **텍스트 시작**: 이전 사용 가능한 위치로 이동(텍스트 노드 끝 또는 원자 컴포넌트 끝)
3. **문서 시작**: 현재 위치에 유지

### 원자 컴포넌트 탐색

#### 전진 이동
- **원자 시작(offset 0)**: 원자 끝(offset 1)으로 이동
- **원자 끝(offset 1)**: 다음 사용 가능한 위치로 이동

#### 후진 이동
- **원자 끝(offset 1)**: 원자 시작(offset 0)으로 이동  
- **원자 시작(offset 0)**: 이전 사용 가능한 위치로 이동

## 경계 동작

### 텍스트 경계
- **텍스트 끝에서 전진**: 다음 위치가 없으면 현재 위치에 유지
- **텍스트 시작에서 후진**: 이전 위치가 없으면 현재 위치에 유지

### 블록 요소 경계
- **블록 요소 내 텍스트 끝에서 전진**: 다음 텍스트로 넘어가지 않고 현재 줄에 유지
- **블록 요소 내 텍스트 시작에서 후진**: 이전 텍스트로 넘어가지 않고 현재 줄에 유지
- 예시: `<p>첫 번째</p><p>두 번째</p>`에서 "첫 번째" 끝에서 전진해도 "두 번째"로 넘어가지 않음

### 문서 경계
- **문서 끝에서 전진**: 현재 위치에 유지
- **문서 시작에서 후진**: 현재 위치에 유지

## 예외 상황

### 빈 텍스트 노드
- 탐색 중 빈 텍스트 노드는 건너뜀
- 다음/이전 비어있지 않은 위치로 직접 이동

### 공백 처리
- 공백 문자(스페이스, 탭)는 일반 문자로 취급
- 각 공백 문자는 하나의 위치로 계산

### 유니코드 문자 처리
- 이모지(🌟, 👍)와 같은 복합 유니코드 문자는 1개의 글자로 취급
- 예: "안녕👍하세요"에서 "👍"는 하나의 문자 단위로 이동
- 한글 자모 결합 문자(가, 나, 다)도 완성된 글자 단위로 취급

### 양방향 텍스트(BiDi) 처리
- 아랍어, 히브리어 등 RTL(Right-to-Left) 텍스트와 LTR(Left-to-Right) 텍스트가 혼재된 경우
- 논리적 순서 vs 시각적 순서 중 **논리적 순서**를 따름 (Windows 표준 동작)
- 예: "Hello مرحبا World"에서 오른쪽 화살표는 논리적 다음 문자로 이동
- 문자 방향 점프 지점에서의 커서 위치 처리 필요

### 줄 바꿈 처리
- **하드 랩(Hard Wrap)**: 실제 줄바꿈 문자가 있는 경우, 줄 경계에서 다음 줄로 이동
- **소프트 랩(Soft Wrap)**: 시각적 줄바꿈만 있는 경우, 논리적 같은 줄 내에서만 이동
- 예: 소프트 랩된 긴 줄에서는 시각적 줄 끝에서 다음 시각적 줄 시작으로 이동

### 중첩 요소
- 중첩된 요소 경계를 매끄럽게 탐색
- 예시: `<div>안녕 <strong>굵게</strong> 세상</div>`
  - "안녕 " 끝에서 전진하면 "굵게" 시작으로 이동

## 구현 요구사항

### Position 정규화
`normalizePosition` 함수는 다음을 수행해야 합니다:
1. 범위를 벗어난 오프셋 처리
2. 빈 텍스트 노드 건너뛰기
3. 원자 컴포넌트가 유효한 오프셋(0 또는 1)만 가지도록 보장
4. 모든 예외 상황에 대해 유효한 위치 반환
5. 유니코드 클러스터 경계 준수 (이모지, 결합 문자 처리)

### 트리 순회
문자 이동에는 다음이 필요합니다:
1. **전진 순회**: 문서 순서로 다음 유효한 커서 위치 찾기
2. **후진 순회**: 역순 문서 순서로 이전 유효한 커서 위치 찾기
3. **원자 감지**: `atomic-component` 클래스가 있는 요소 식별
4. **BiDi 텍스트 처리**: 논리적 순서 기반 이동 로직
5. **줄바꿈 모드 감지**: 하드 랩 vs 소프트 랩 구분

### 성능 고려사항
- 긴 문서에서의 반응성 유지
- 키 반복 입력 시 부드러운 커서 이동
- 복잡한 유니코드 문자 처리 시 지연 최소화

## 테스트 케이스

### 기본 이동
- 텍스트에서 원자 컴포넌트로의 전환
- 원자에서 텍스트로의 전환
- 원자 컴포넌트들 사이
- 여러 문자 단계
- 텍스트 경계 처리

### 복잡한 시나리오
- 혼합 콘텐츠가 있는 중첩 요소
- 원자와 텍스트 요소가 혼합된 경우
- 빈 텍스트 노드
- 단일 문자 텍스트 노드
- 공백 처리

### 고급 시나리오
- 양방향 텍스트 혼재 상황
- 복합 유니코드 문자 (이모지, 결합 문자)
- 하드 랩 vs 소프트 랩 환경
- 블록 요소 경계 처리
- 중첩된 인라인 요소 탐색

## API 인터페이스

```typescript
interface EditorSelection {
  modify(alter: 'move', direction: 'forward' | 'backward', granularity: 'character'): void
}

interface Position {
  node: Node
  offset: number
}

function normalizePosition(position: Position): Position
function isAtomicComponent(node: Node): boolean
function isBlockElement(node: Node): boolean
function getNextCharacterPosition(position: Position): Position | null
function getPreviousCharacterPosition(position: Position): Position | null
function getUnicodeClusterBoundary(text: string, offset: number, direction: 'forward' | 'backward'): number
function isBidiText(text: string): boolean
function getLogicalNextPosition(position: Position, direction: 'forward' | 'backward'): Position | null
```

이 명세는 모든 에디터 시나리오에서 일관되고 예측 가능한 문자 이동 동작을 보장합니다.